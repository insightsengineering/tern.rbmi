% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tabulate_rbmi.R
\name{tabulate_rbmi}
\alias{tabulate_rbmi}
\alias{h_tidy_pool}
\alias{tidy.pool}
\alias{s_rbmi_lsmeans}
\alias{a_rbmi_lsmeans}
\alias{summarize_rbmi}
\title{Tabulation of RBMI Results}
\usage{
h_tidy_pool(x)

\method{tidy}{pool}(x)

s_rbmi_lsmeans(df, .in_ref_col, show_relative = c("reduction", "increase"))

a_rbmi_lsmeans(df, .in_ref_col, show_relative = c("reduction", "increase"))

summarize_rbmi(
  lyt,
  ...,
  table_names = "rbmi_summary",
  .stats = NULL,
  .formats = NULL,
  .indent_mods = NULL,
  .labels = NULL
)
}
\arguments{
\item{x}{(\code{pool})}

\item{df}{input dataframe}

\item{.in_ref_col}{boolean variable, if reference column is specified}

\item{show_relative}{should the "reduction" (\code{control - treatment}, default) or the "increase"
(\code{treatment - control}) be shown for the relative change from baseline?}

\item{lyt}{(\code{layout})\cr input layout where analyses will be added to.}

\item{...}{additional argument.}

\item{table_names}{(\code{character})\cr this can be customized in case that the same \code{vars} are analyzed multiple times,
to avoid warnings from \code{rtables}.}

\item{.stats}{(\code{character})\cr statistics to select for the table.}

\item{.formats}{(named \code{character} or \code{list})\cr formats for the statistics.}

\item{.indent_mods}{(named \code{integer})\cr indent modifiers for the labels.}

\item{.labels}{(named \code{character})\cr labels for the statistics (without indent).}
}
\value{
A dataframe
}
\description{
These functions can be used to produce tables from a fitted RBMI produced
}
\section{Functions}{
\itemize{
\item \code{h_tidy_pool}: Helper function to produce data frame with results
of pool for a single visit

\item \code{tidy.pool}: Helper method (for \code{\link[broom:reexports]{broom::tidy()}}) to prepare a data frame from an
\code{pool} rbmi object containing the LS means and contrasts and multiple visits

\item \code{s_rbmi_lsmeans}: Statistics function which is extracting estimates from a tidied LS means
data frame.

\item \code{a_rbmi_lsmeans}: Formatted Analysis function which can be further customized by calling
\code{\link[rtables:make_afun]{rtables::make_afun()}} on it. It is used as \code{afun} in \code{\link[rtables:analyze]{rtables::analyze()}}.

\item \code{summarize_rbmi}: Analyze function for tabulating LS means estimates from tidied
rbmi \code{pool} results.
}}

\examples{
library(rtables)
library(dplyr)
library(broom)
library(rbmi)

data <- antidepressant_data
levels(data$THERAPY) <- c("PLACEBO", "DRUG") # This is important! The order defines the computation order later
missing_var <- "CHANGE"
vars <- list(
  id = "PATIENT",
  visit = "VISIT",
  expand_vars = c("BASVAL", "THERAPY"),
  group = "THERAPY"
)
covariates <- list(
  draws = c("BASVAL*VISIT", "THERAPY*VISIT"),
  analyse = c("BASVAL")
)
draws_vars <- set_vars(
  outcome = missing_var,
  visit = vars$visit,
  group = vars$group,
  covariates = covariates$draws
)
impute_references <- c("DRUG" = "PLACEBO", "PLACEBO" = "PLACEBO")
draws_method <- method_bayes()
analyse_fun <- ancova
analyse_fun_args <- list(
  vars = set_vars(
    outcome = missing_var,
    visit = vars$visit,
    group = vars$group,
    covariates = covariates$analyse
  )
)
pool_args <- list(
  conf.level = formals(pool)$conf.level,
  alternative = formals(pool)$alternative,
  type = formals(pool)$type
)
debug_mode <- FALSE

data <- data \%>\%
  dplyr::select(dplyr::all_of(c(vars$id, vars$group, vars$visit, vars$expand_vars, missing_var))) \%>\%
  dplyr::mutate(dplyr::across(.cols = vars$id, ~ as.factor(.x))) \%>\%
  dplyr::arrange(dplyr::across(.cols = c(vars$id, vars$visit)))
data_full <- do.call(
  expand_locf,
  args = list(
    data = data,
    vars = c(vars$expand_vars, vars$group),
    group = vars$id,
    order = c(vars$id, vars$visit)
  ) \%>\%
    append(lapply(data[c(vars$id, vars$visit)], levels))
)

data_full <- data_full \%>\%
  dplyr::group_by(dplyr::across(vars$id)) \%>\%
  dplyr::mutate(!!vars$group := Filter(Negate(is.na), .data[[vars$group]])[1])

# there are duplicates - use first value
data_full <- data_full \%>\%
  dplyr::group_by(dplyr::across(c(vars$id, vars$group, vars$visit))) \%>\%
  dplyr::slice(1) \%>\%
  dplyr::ungroup()
# need to have a single ID column
data_full <- data_full \%>\%
  tidyr::unite("TMP_ID", dplyr::all_of(vars$id), sep = "_#_", remove = FALSE) \%>\%
  dplyr::mutate(TMP_ID = as.factor(TMP_ID))
draws_vars$subjid <- "TMP_ID"

data_ice <- data_full \%>\%
  dplyr::arrange(dplyr::across(.cols = c("TMP_ID", vars$visit))) \%>\%
  dplyr::filter(is.na(.data[[missing_var]])) \%>\%
  dplyr::group_by(TMP_ID) \%>\%
  dplyr::slice(1) \%>\%
  dplyr::ungroup() \%>\%
  dplyr::select(all_of(c("TMP_ID", vars$visit))) \%>\%
  dplyr::mutate(strategy = "MAR")

draws_obj <- draws(
  data = data_full,
  data_ice = data_ice,
  vars = draws_vars,
  method = draws_method
)
impute_obj <- impute( # @TODO: add support of `update_stategy` argument
  draws_obj,
  references = impute_references
)

ref_levels <- levels(impute_obj$data$group[[1]])
names(ref_levels) <- c("ref", "alt")
analyse_fun_args$vars$subjid <- "TMP_ID"
analyse_obj <- do.call(
  analyse, # @TODO: add support of `delta` argument
  args = list(
    imputations = impute_obj,
    fun = analyse_fun
  ) \%>\%
    append(analyse_fun_args)
)
pool_obj <- do.call(
  pool,
  args = list(
    results = analyse_obj
  ) \%>\%
    append(pool_args)
)

h_tidy_pool(pool_obj$pars[1:3])
df <- tidy(pool_obj)
df

s_rbmi_lsmeans(df[2, ], .in_ref_col = FALSE)

afun <- make_afun(a_rbmi_lsmeans)
afun(df[2, ], .in_ref_col = FALSE)

basic_table() \%>\%
  split_cols_by("group", ref_group = levels(df$group)[1]) \%>\%
  split_rows_by("visit", split_label = "Visit", label_pos = "topleft") \%>\%
  summarize_rbmi() \%>\%
  build_table(df)

}
